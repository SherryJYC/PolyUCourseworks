<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Draw a point with a mouse click</title>
</head>

<body onload="main()">
    <canvas id="webgl" width="400" height="400">
        Please use a browser that supports "canvas"
    </canvas>

    <script>
        var VSHADER_SOURCE =
          'attribute vec4 a_Position;\n' +
            'void main() {\n' +
            '  gl_Position = a_Position;\n' +
            '  gl_PointSize = 10.0;\n' +
            '}\n';

        // Fragment shader program
        var FSHADER_SOURCE =
          'void main() {\n' +
            '  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n' +
            '}\n';

        var mode = 'i'; //i for default; d for drw;v for vertex reposition

        function main() {
            // Retrieve <canvas> element
            var canvas = document.getElementById('webgl');

            // Get the rendering context for WebGL
            var gl = getWebGLContext(canvas);
            if (!gl) {
                console.log('Failed to get the rendering context for WebGL');
                return;
            }

            // Initialize shaders
            if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {
                console.log('Failed to intialize shaders.');
                return;
            }

            // Initializa buffers
            initVertexBuffers(gl);


            // Register function (event handler) to be called on a mouse press
            canvas.onmousedown = function (ev) { click(ev, gl, canvas); };

            // Register function (event handler) to be called on a key press
            document.onkeydown = function (ev) { keyDown(ev, gl, canvas); };

            // Specify the color for clearing <canvas>
            gl.clearColor(1.0, 1.0, 1.0, 1.0);

            // Clear <canvas>
            gl.clear(gl.COLOR_BUFFER_BIT);
        }

        var g_points = []; // The array for the position of a mouse press


        var vertexBuffer;

        function click(ev, gl, canvas) {
            if (mode === 'd') {
                var x = ev.clientX; // x coordinate of a mouse pointer
                var y = ev.clientY; // y coordinate of a mouse pointer
                var rect = ev.target.getBoundingClientRect();

                x = ((x - rect.left) - canvas.width / 2) / (canvas.width / 2);
                y = (canvas.height / 2 - (y - rect.top)) / (canvas.height / 2);
                // Store the coordinates to g_points array
                g_points.push(x);
                g_points.push(y);
                var len = g_points.length;

                // Bind the buffer object to target
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                // Write date into the buffer object
                gl.bufferData(gl.ARRAY_BUFFER, len * 4, gl.DYNAMIC_DRAW);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array(g_points))

                gl.drawArrays(gl.POINTS, 0, len / 2);

            }
        }

        function keyDown(ev, gl, canvas) {
            var keyCode = ev.keyCode;
            if (keyCode === 68) { //Drawing mode
                if (mode === 'd') {
                    alert("You have already entered Drawing Mode.");
                    return;
                } else if (mode === 'v') {
                    alert("You are currently in Vertex Reposition Mode. If you want to enter Drawing Mode, please" +
                      "enter ESC to exit from Vertex Reposition Mode fist.");
                    return;
                }
                alert("You entered Drawing Mode.");
                mode = 'd';
                gl.clear(gl.COLOR_BUFFER_BIT);
                g_points = [];
            } else if (keyCode === 83) { //Save
                if (mode !== 'i') {
                    alert("Please exit Drawing Mode or Vertex Reposition Mode first.");
                    return;
                }
                if (checkVertex()) {
                    doSave(g_points, "text/latex", "hello.txt");
                    alert("Save SUCCESSFULLY!");
                } else {
                    alert("Save FAILED! The polygon is invalid!");
                }
                return;
            } else if (keyCode === 86) { //Vertex Reposition mode
                if (mode === 'v') {
                    alert("You have already entered Vertex Reposition Mode.");
                    return;
                } else if (mode === 'd') {
                    alert("You are currently in Drawing Mode. If you want to enter Vertex Reposition Mode, please" +
                      "enter ESC to exit from Drwating Mode fist.");
                    return;
                }
                alert("You entered Vertex Reposition Mode.");
                mode = 'v';
            } else if (keyCode === 27) { //Exit
                if (mode === 'd') {
                    gl.drawArrays(gl.LINE_LOOP, 0, g_points.length / 2);
                    alert("You exit from Drawing Mode");
                    mode = 'i';
                    return;
                } else if (mode === 'v') {
                    alert("You exit from Vertex Reposition Mode");
                    mode = 'i';
                    return;
                } else {
                    var exit = confirm("Do you want to exit the program?", true);
                }
            }
        }

        function checkVertex() {
            return true;
        }

        function doSave(value, type, name) {
            var blob;
            if (typeof window.Blob == "function") {
                blob = new Blob([value], { type: type });
            } else {
                var BlobBuilder = window.BlobBuilder || window.MozBlobBuilder || window.WebKitBlobBuilder || window.MSBlobBuilder;
                var bb = new BlobBuilder();
                bb.append(value);
                blob = bb.getBlob(type);
            }
            var URL = window.URL || window.webkitURL;
            var bloburl = URL.createObjectURL(blob);
            var anchor = document.createElement("a");
            if ('download' in anchor) {
                anchor.style.visibility = "hidden";
                anchor.href = bloburl;
                anchor.download = name;
                document.body.appendChild(anchor);
                var evt = document.createEvent("MouseEvents");
                evt.initEvent("click", true, true);
                anchor.dispatchEvent(evt);
                document.body.removeChild(anchor);
            } else if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, name);
            } else {
                location.href = bloburl;
            }
        }

        function saveVertex(fileName, content) {
            var aLink = document.createElement('a');
            var blob = new Blob([content]);
            var evt = document.createEvent("HTMLEvents");
            evt.initEvent("click", false, false); //initEvent 不加后两个参数在FF下会报错, 感谢 Barret Lee 的反馈
            aLink.download = fileName;
            aLink.href = URL.createObjectURL(blob);
            aLink.dispatchEvent(evt);
        }

        function initVertexBuffers(gl) {
            vertexBuffer = gl.createBuffer();
            // Create a buffer object
            if (!vertexBuffer) {
                console.log('Failed to create the buffer object');
                return -1;
            }

            // Bind the buffer object to target
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            // Write date into the buffer object
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(g_points), gl.DYNAMIC_DRAW);

            var a_Position = gl.getAttribLocation(gl.program, 'a_Position');
            if (a_Position < 0) {
                console.log('Failed to get the storage location of a_Position');
                return -1;
            }

            // Assign the buffer object to a_Position variable
            gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);

            // Enable the assignment to a_Position variable
            gl.enableVertexAttribArray(a_Position);

        }


        //help methods
        function getWebGLContext(canvas, opt_debug) {
            // Get the rendering context for WebGL
            var gl = setupWebGL(canvas);
            if (!gl) return null;

            return gl;
        }

        function setupWebGL(canvas, opt_attribs, opt_onError) {
            function handleCreationError(msg) {
                var container = document.getElementsByTagName("body")[0];
                //var container = canvas.parentNode;
                if (container) {
                    var str = window.WebGLRenderingContext ? OTHER_PROBLEM : GET_A_WEBGL_BROWSER;
                    if (msg) {
                        str += "<br/><br/>Status: " + msg;
                    }
                    container.innerHTML = makeFailHTML(str);
                }
            };

            opt_onError = opt_onError || handleCreationError;

            if (canvas.addEventListener) {
                canvas.addEventListener("webglcontextcreationerror",
                  function (event) {
                      opt_onError(event.statusMessage);
                  },
                  false);
            }
            var context = create3DContext(canvas, opt_attribs);
            if (!context) {
                if (!window.WebGLRenderingContext) {
                    opt_onError("");
                } else {
                    opt_onError("");
                }
            }

            return context;
        }

        function create3DContext(canvas, opt_attribs) {
            var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
            var context = null;
            for (var ii = 0; ii < names.length; ++ii) {
                try {
                    context = canvas.getContext(names[ii], opt_attribs);
                } catch (e) {
                }
                if (context) {
                    break;
                }
            }
            return context;
        }

        function initShaders(gl, vshader, fshader) {
            var program = createProgram(gl, vshader, fshader);
            if (!program) {
                console.log('Failed to create program');
                return false;
            }

            gl.useProgram(program);
            gl.program = program;

            return true;
        }

        function createProgram(gl, vshader, fshader) {
            // Create shader object
            var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);
            var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);
            if (!vertexShader || !fragmentShader) {
                return null;
            }

            // Create a program object
            var program = gl.createProgram();
            if (!program) {
                return null;
            }

            // Attach the shader objects
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);

            // Link the program object
            gl.linkProgram(program);

            // Check the result of linking
            var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (!linked) {
                var error = gl.getProgramInfoLog(program);
                console.log('Failed to link program: ' + error);
                gl.deleteProgram(program);
                gl.deleteShader(fragmentShader);
                gl.deleteShader(vertexShader);
                return null;
            }
            return program;
        }

        function loadShader(gl, type, source) {
            // Create shader object
            var shader = gl.createShader(type);
            if (shader == null) {
                console.log('unable to create shader');
                return null;
            }

            // Set the shader program
            gl.shaderSource(shader, source);

            // Compile the shader
            gl.compileShader(shader);

            // Check the result of compilation
            var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (!compiled) {
                var error = gl.getShaderInfoLog(shader);
                console.log('Failed to compile shader: ' + error);
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }


    </script>
</body>
</html>
